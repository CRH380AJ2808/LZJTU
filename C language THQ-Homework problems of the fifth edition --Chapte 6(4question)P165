////【THQ第六章课后练习】6-1 用筛选法求100之内的所有素数
//1.准备数据  1-100之内的数保存在整形数组中
//2.1不是素数 先将1划掉---->采用0进行比较
//3.for()
//    1.找一个未被划掉的数据———>数组中不是0的数
//    2.用该数模其后续剩余的所有数据
//      能够被整除的，将其剔除掉
//      不能被整除的，保留
//4.循环结束后 数组中所有非0的数据就是最终所要的数

//int main()
//{
//    int i, j;
//    int arr[100];
//    //向arr数组中填充1~100所有数据
//    for (i = 0; i < 100; ++i)
//    {
//        arr[i] = i + 1;
//    }
//
//    //1不是素数 只需将1划掉 --->s使用0进行填充
//    arr[0] = 0;
//
//    for (i = 0; i < 100; ++i)
//    {
//        if (0 == arr[i])
//            continue;
//        //现在需要使用a[i]去模其之后的数据
//        for (j = i + 1; j < 100; ++j)
//        {
//            if (0!=arr[j] && arr[j] % arr[i] == 0)
//            {
//                arr[j] = 0;
//            }
//        }
//    }
//    //使用for循环输出所有素数
//    for (i = 0; i < 100; i++)
//    {
//        if (0 != arr[i])
//        {
//            printf("%d ", arr[i]);
//        }
//    }
//    printf("\n");
//    return 0;
//}



//////6-2选择法对10个整数进行排序
////1.10个整形数据准备好----排序之前
////   a.可以直接在程序中给死
////   b.可以通过输入
////2.选择法
////3.升序、降序——>假设：升序
//int main()
//{
//    int i, j;
//    int maxPos;//标记最大元素所在位置
//    int arr[10] = { 2,8,3,9,5,7,1,4,0,6 };
//    int size = sizeof(arr) / sizeof arr[0];
//    
//    //排序之前数组中元素的输出
//    for (i = 0; i < size; ++i)
//    {
//        printf("%d ", arr[i]);
//    }
//    printf("\n");
//    
//    for (i = 0; i < size; ++i)//外循环控制选择的总趟数
//    {
//        //具体选择的方式
//        //选择法进行排序
//        maxPos = 0;
//        for (j = 1; j < size-i; ++j)
//        {
//            if (arr[j] > arr[maxPos])
//            {
//                maxPos = j;
//            }
//        }
//
//        //已经找到最大元素所在位置
//        int temp;
//        temp = arr[maxPos];
//        arr[maxPos] = arr[size - i - 1];
//        arr[size - i - 1] = temp;
//
//    }
//    
//    //输出排序好的结果
//    for (i = 0; i < size; i++)
//    {
//        printf("%d ", arr[i]);
//    }
//    printf("\n");
//    return 0;
//}



////6-6输出杨辉三角的前十行
//1.可以采用二维数组来保存杨辉三角的数
//2.第0列中的所有数据都是1
//3.对角线上所有的元素都是1
//行下标与列下标是相等的
//4.其他元素：arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1]
//5.int arr[10][10];

//int main()
//{
//    int arr[10][10];//保存所给的杨辉三角中的数据
//
//    int i, j;
//    for (i = 0; i < 10; ++i)
//    {
//        //给杨辉三角中的每一行进行赋值
//        for (j = 0; j <= i; ++j)
//        {
//            //第列对角线上的数据都是1
//            if (0 == j || i == j)
//            {
//                arr[i][j] = 1;
//            }
//            else
//                //其他行
//                arr[i][j] = arr[i - 1][j] + arr[i - 1][j - 1];
//        }
//    }
//    for (i = 0; i < 10; ++i)
//    {
//        for (j = 0; j <= i; ++j)
//        {
//            printf(" %6d ", arr[i][j]);
//        }
//        printf("\n");
//    }
//    return 0;
//}



////6-7输出魔方阵
//
////本题只考虑奇魔方阵：----
//int main()
//{
//    int arr[100][100] = { 0 };
//    int N;//表示魔方的阶数
//    int row = 0, col = 0;
//    int prevRow = 0, preCol = 0;//前一个元素所在的行与列
//    int i,j;
//    while (1)
//    {
//        printf("请输入魔方阵的阶数,阶数为3~100之内的奇数：");
//        scanf_s("%d", &N);
//        if (0 != N % 2 && (N >= 3 && N < 100))
//        {
//            break;
//        }
//    }
//
//    //放置1：第0行最中间的位置
//    col = N / 2;
//    arr[row][col] = 1;
//
//
//    //对剩余的N^2-1个元素，按照以下规则来进行存放
//    for (i = 2; i <= N * N; ++i)
//    {
//        //下一个元素存放在当前元素的上一行下一列
//        row--;
//        col++;
//         
//        if (row < 0)
//        {
//            row = N - 1;
//        }
//        if (col >= N)
//        {
//            col = 0;
//        }
//        if (arr[row][col])
//        {
//            //row、col 该位置已经有元素了-----当前列的下一行：前一个元素的下一行
//            row = prevRow + 1;
//            col = preCol;
//        }
//        arr[row][col] = i;
//        prevRow = row;
//        preCol = col;
//
//    }
//
//   //将魔方阵输出
//    for (i = 0; i < N; ++i)
//    {
//        for (j = 0; j < N; ++j)
//        {
//            printf("%4d", arr[i][j]);
//        }
//        printf("\n");
//    }
//    return 0;
//}
